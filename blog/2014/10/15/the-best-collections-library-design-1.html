<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>The best collections library design, part 1</title>
    <meta name="description" content="Mostly programming related.
">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="http://yourdomain.com/2014/10/15/the-best-collections-library-design-1.html">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Jules Jacobs' blog</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">The best collections library design, part 1</h1>
    <p class="post-meta">Oct 15, 2014</p>
  </header>

  <article class="post-content">
    <p>Collections are the centerpiece of the standard library of a programming language. If there’s any library that’s important to get right, it’s the collections library. Yet designs in different languages differ greatly, and some are far better than others. In this series I will explore the design space of collections libraries and evaluate the pros and cons of each design.</p>

<p>There are many different types of collections: lists, arrays, sets, bags, maps (both sorted and hash based variants), queues, stacks, heaps, and more. These represent different data, allow different operations, and even when they allow the same operations they may have different efficiency. Some languages even have multiple variants of each collection, like mutable and immutable. On the other hand, these collections support many common operations such as iteration, filter, map, and fold. In this episode I’m going to focus on those kinds of operations.</p>

<p>I’m going to mix and mash different languages in this series. Even if you are not familiar with all of those languages, you should still be able to follow the main points.</p>

<h2 id="the-story-of-map">The story of map</h2>

<p>The map function is one of the core operations of a modern collections library:</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">map</span> <span class="o">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">CollectionType</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">CollectionType</span> <span class="n">b</span></code></pre></div>

<p>This also goes by the name collect (Smalltalk) and Select (C#). It takes a function, and transforms a collection by applying that function to each element. Simple, right? I’m going to show you why this type for map is <strong>wrong</strong>.</p>

<h3 id="map-in-haskell">Map in Haskell</h3>

<p>For lists, arrays, stacks and queues everything is fine:</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">map</span> <span class="o">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">List</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">List</span> <span class="n">b</span>
<span class="n">map</span> <span class="o">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Stack</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Stack</span> <span class="n">b</span>
<span class="n">etc</span><span class="o">.</span></code></pre></div>

<p>The problems start to show when we try sorted sets:</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">map</span> <span class="o">:</span> <span class="kt">Ord</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Set</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Set</span> <span class="n">b</span></code></pre></div>

<p>Elements in sorted sets need to support a comparison operation. That’s what the <code>Ord a,b</code> is saying. It gets even worse when we look at strings:</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">map</span> <span class="o">:</span> <span class="p">(</span><span class="kt">Char</span> <span class="o">-&gt;</span> <span class="kt">Char</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">String</span></code></pre></div>

<p>Since strings always contain characters, the function must also return characters in order to transform a string. In Haskell this kind of problem shows up in the Functor, Monad, Traversable and Foldable type classes. There is a MonoFunctor/MonoTraversable/MonoFoldable package that tries to solve this problem by defining a different kind of traversable/foldable that works on collections such as strings. The those type classes aren’t a replacement for the old ones, since they only allow operations of type <code>(a -&gt; a)</code> and in general map can support <code>(a -&gt; b)</code>. Those type classes also do not do anything to solve the problem of sets. For that we could introduce yet another set of type classes OrdFunctor/OrdTraversable/OrdFoldable. Then we encounter hash based sets, and we need HashFoldable/HashTraversable/HashFunctor. Not good.</p>

<h3 id="map-in-scala">Map in Scala</h3>

<p>Scala takes an even more ambitious approach. It will try to upgrade your collection based on the function you’re mapping (or downgrade, depending on your point of view). If you are mapping a <code>Char -&gt; Char</code> function over your string, the output will be a string. However if you are mapping a <code>Char -&gt; Int</code> function  over your string, your output will suddenly become a <code>Vector[Int]</code>. Similarly, if you map a function over a SortedSet and the resulting elements do not support ordering, then your set will be downgraded to a non-sorted set. This is a “just do the right thing” system. Problem solved! The <strong>correct</strong> type of <code>map</code> is:</p>

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">That</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">,</span> <span class="n">coll</span><span class="k">:</span> <span class="kt">FilterMonadic</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Repr</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">bf</span><span class="k">:</span> <span class="kt">CanBuildFrom</span><span class="o">[</span><span class="kt">Repr</span>, <span class="kt">B</span>, <span class="kt">That</span><span class="o">])</span><span class="k">:</span> <span class="kt">That</span></code></pre></div>

<p>Back to reality! The Scala documentation displays bizarre types such as the type of <code>String.map</code> being <code>map[B](f: (A) ⇒ B): String[B]</code>. What’s a <code>String[B]</code>? It doesn’t exist. The real type of map is <code>String.map[B, That](f: (Char) ⇒ B)(implicit bf: CanBuildFrom[String, B, That]): That</code>. This complicated machinery is needed for Scala to upgrade/downgrade your collections when mapping. If you thought that was complicated consider that Scala has subtyping too, and types may be co- and contravariant. What happens if you concatenate a <code>List[Int] ++ SortedSet[Int]</code> (answer: you get a list). What if you change the order and concatenate a <code>SortedSet[Int] ++ List[Int]</code> (answer: you get a sortedset). Now consider that the parameter type itself may be different and may or may not support comparison <code>SortedSet[T] ++ List[Q]</code>. Next consider that the concrete type of a value may be a subtype of the static type of the value. So what happens if we put a <code>List[Int]</code> and a <code>SortedSet[Int]</code> and another <code>SortedSet[Int]</code> in some order together in a <code>List</code>, and then fold the <code>++</code> operator over that? The concrete type of the result will be some function of the static types and the concrete types and the order in which they appeared in the list, and the static type will be some function of the static types.</p>

<p>Here’s a puzzle for you:</p>

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">sumBy</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span><span class="o">(</span><span class="kt">A</span> <span class="o">=&gt;</span> <span class="kt">Int</span><span class="o">),</span> <span class="n">xs</span><span class="k">:</span><span class="kt">Traversable</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">sum</span>

<span class="n">sumBy</span><span class="o">((</span><span class="n">s</span><span class="k">:</span><span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span><span class="o">,</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"hello"</span><span class="o">,</span> <span class="s">"my"</span><span class="o">,</span> <span class="s">"world"</span><span class="o">))</span></code></pre></div>

<p>What does that return? We are summing the elements by length. The length of the strings is 5+2+5 = 12. Right? No: the sumBy function first maps over the collection, creating a collection of lenghts. In this case that will be <code>Set(5,2,5)</code>, but sets don’t have duplicates! So that becomes <code>Set(5,2)</code> and sumBy returns 7. Had we used List instead of Set, the answer would have been 12, of course. All that complexity, and the end result is not “just do the right thing”, the result is broken abstractions…</p>

<h3 id="map-in-scheme">Map in Scheme</h3>

<p>In Scheme each data type comes with its own map function. You have list-map, vector-map, set-map, etc. This is clearly not a good approach either, because it requires a different function for each (collection,operation) pair. And what if you want to map a function over a list, but get a vector out? It would be wasteful to map a function over the list to produce an intermediate list, and then convert that intermediate list into a vector.</p>

<h3 id="map-in-ruby-and-python">Map in Ruby and Python</h3>

<p>In Ruby and Python <code>map</code> always returns an array. Map over an array? Get an array back. Map over a string? Get an array back. Map over a set? Get an array back. Believe it or not, this is much closer to the best design than any of the other solutions we’ve talked about so far! This still has a big disadvantage: if you chain map multiple times then on each step you build an intermediate collection. If you do <code>xs.map{|x| x*2}.map{|y| y+1}</code> then one useless intermediate array is built. It would be much better to execute <code>xs.map{|x| x*2 + 1}</code>. The same goes for all operations that create intermediate arrays: map, filter, zip, flatmap, etc.</p>

<h2 id="what-is-not-the-best-collections-library-design">What is not the best collections library design</h2>

<p>We have already figured out a few examples of what not to base a collections library on:</p>

<ol>
  <li>Haskell’s traversable/foldable/functor, or mono- or ord- or hash- versions of those</li>
  <li>Scala’s system where the result type is chosen with magic rules</li>
  <li>Scheme’s different set of functions for each collection</li>
  <li>Ruby and Python’s always return an array</li>
</ol>

<p>Here are some of the requirements of a good collections library:</p>

<ol>
  <li>It should support each operation for any collection</li>
  <li>It should not have any magic rules by which the type of intermediate collections is determined. In fact, it should not build any intermediate collections for chains of multiple operations <em>at all</em>.</li>
  <li>You should be able to put any collection type in, and get any collection type out, without the overhead of an additional conversion</li>
</ol>

<h2 id="the-solution">The solution</h2>

<p>The collection operations should not be implemented on the collections themselves, they should be implemented on a sequence abstraction <code>Seq a</code>. We get these types:</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">map</span> <span class="o">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Seq</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Seq</span> <span class="n">b</span>
<span class="n">filter</span> <span class="o">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Seq</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Seq</span> <span class="n">a</span>
<span class="n">flatmap</span> <span class="o">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Seq</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Seq</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Seq</span> <span class="n">b</span>
<span class="n">fold</span> <span class="o">:</span> <span class="p">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="kt">Seq</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">s</span>
<span class="n">zip</span> <span class="o">:</span> <span class="kt">Seq</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Seq</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Seq</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="n">etc</span><span class="o">.</span></code></pre></div>

<p>In addition we define conversions to and from each collection type:</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">fromList</span> <span class="o">:</span> <span class="kt">List</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Seq</span> <span class="n">a</span>
<span class="n">toList</span> <span class="o">:</span> <span class="kt">Seq</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">List</span> <span class="n">a</span>

<span class="n">fromSet</span> <span class="o">:</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">Set</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Seq</span> <span class="n">a</span>
<span class="n">toSet</span> <span class="o">:</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">Seq</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Set</span> <span class="n">a</span>

<span class="n">fromString</span> <span class="o">:</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Seq</span> <span class="kt">Char</span>
<span class="n">toString</span> <span class="o">:</span> <span class="kt">Seq</span> <span class="kt">Char</span> <span class="o">-&gt;</span> <span class="kt">String</span></code></pre></div>

<p>This way the only thing a collection needs to have to support the full collections API is a conversion to and from <code>Seq</code>. The collections operations such as <code>map</code> and <code>filter</code> can be implemented on <code>Seq</code> without constructing fully realized intermediate collections. This gives us efficient composition. With the right sequence type the conversion to and from other collection types is also cheap, so that doing <code>fromSet.map(x =&gt; f(x)).toSet</code> is just as fast as a direct map on a set would be.</p>

<p>In the next episode I will look at languages that already have a universal sequence abstraction, and I will compare different sequence abstractions such as lazy lists, iterators, unfolds and folds.</p>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Jules Jacobs' blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>Jules Jacobs' blog</li>
          <li><a href="mailto:julesjacobs@gmail.com">julesjacobs@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/julesjacobs">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">julesjacobs</span>
            </a>
          </li>
          

          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Mostly programming related.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
