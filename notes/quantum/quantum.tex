
\documentclass[a4paper, 11pt]{article}
\usepackage[a4paper,left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{xspace}
\usepackage[bitstream-charter]{mathdesign}
\usepackage{parskip}
\usepackage{microtype}
\usepackage{textcomp}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage{braket}

\usepackage[all]{hypcap}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=blue,
}
\usepackage[nameinlink,noabbrev]{cleveref}
\usepackage{float}
\usepackage{listings}
\usepackage{color}
\usepackage[dvipsnames]{xcolor}
\usepackage{tcolorbox}
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, while, do, else, case, break, val, then, Definition, Check, Lemma, Proof, Qed, Inductive, Fixpoint, match, for, class, object, extends, override, def, if},
  keywordstyle=\color{blue},
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily
}

\lstset{
   columns=fullflexible,
   language=JavaScript,
   extendedchars=true,
   basicstyle=\small\ttfamily,
   literate=
    % {epsilon}{$\epsilon$}1
    % {empty}{$\emptyset$}1
    % {forall}{$\forall$}1
    % {exists}{$\exists$}1
    % {<->}{$\iff$}1
    {->}{$\to\ $}1
    % {<-}{$\leftarrow\ $}1
    {=>}{$\implies\ $}1
    % {fun}{$\lambda$}1
    % {and}{$\wedge$}1
    % {or}{$\vee$}1
    {cdot}{$\cdot$ }1
}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}

\usepackage{amsmath}
\usepackage{amsthm}

\usepackage[shortlabels]{enumitem}
\setitemize{noitemsep, topsep=1pt, leftmargin=*}
\setenumerate{noitemsep, topsep=1pt, leftmargin=*}
% \setdescription{noitemsep, topsep=0pt, leftmargin=*}
\setdescription{itemsep=.5pt, topsep=0pt, leftmargin=8pt}
\usepackage{mathpartir}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{corollary}{Corollary}[theorem]
\usepackage{adjustbox}
% \usepackage[notref,notcite]{showkeys}
\usepackage{todonotes}
\usepackage{multicol}

% =========== TIKZ ===========
% \usepackage{graphicx}
% \usepackage{tikz}
% \usetikzlibrary{shapes.geometric, arrows}
% \usetikzlibrary{fit}
% \usetikzlibrary{svg.path}
% % \usetikzlibrary{graphdrawing}
% % \usetikzlibrary{graphdrawing.force}
% % \usetikzlibrary{graphdrawing.layered}
% \usetikzlibrary{decorations}
% \usetikzlibrary{decorations.markings}
% \usetikzlibrary{backgrounds}

\newcommand{\ie}{\textit{i.e.,}\xspace}

\usepackage{lipsum}

\title{A quick introduction to quantum programming}
\author{Jules Jacobs}

\begin{document}
\maketitle

% \begin{abstract}
%   This note is a quick introduction to quantum programming.
% \end{abstract}

\subsection{Quantum states}

Imagine that we have a box with some physical system inside of it, with a finite set $S$ of possible states.
A probability distribution over $S$ is a vector $\vec{p}$ of probabilities, one probability $p_i \in [0,1]$ for each state $x \in S$, such that $\sum_x p_x = 1$.

A \emph{quantum state} over $S$, on the other hand, is a vector $\vec{\phi}$ of \emph{probability amplitudes}, one complex number $\phi_x \in \C$ for each state $x \in S$.
If we \emph{measure} such a quantum state, we obtain the outcome $x$ with probability $p_x = |\phi_x|^2$.
Thus, in order for $\phi$ to be a proper quantum state, we must have $\sum_x |\phi_x|^2 = 1$.

\subsection{Time evolution}

Imagine that the system in the box evolves in time according to some laws of physics.
In quantum mechanics, these laws of physics are given by a matrix $U$ that multiplies the state every time step.
If the state is currently $\phi$, then at the next time step the state is $U\phi$.
If there are $n = |S|$ possible states, then $U$ is an $n \times n$ matrix.
Only matrices that preserve the condition that the probabilities sum to $1$ are allowed: if $\sum_x |\phi_x|^2 = 1$ we must have $\sum_x |(U\phi)_x|^2 = 1$.
Such matrices are called \emph{unitary}.

It might be helpful to compare with probabilistic evolution of the state as in a Markov chain.
In that case we model the state with a probability vector $\vec{p}$ and we multiply this vector with a matrix $M$ at each time step.
If the state is currently $p$, then at the next time step the state is $Mp$.
Matrices that preserve the condition that all probaiblities are non-negative and that their sum remains $1$ are called \emph{stochastic matrices}.
The entry $M_{xy}$ of the matrix is the probability that the system will step to state $y$, if the state is currently $x$.
Similarly, the entry $U_{xy}$ of the unitary matrix, is the probability amplitude of next state being $y$, if the state is currently $x$.

\subsection{What a quantum computer is}

A quantum computer with state set $S$ is a device where we can \emph{input} such a matrix $U$ and an initial state $\phi$.
It will then do one step of time evolution to $\phi' = U\phi$, and it will \emph{measure} the new state $\phi'$ and tell us which outcome $x \in S$ it got.
This outcome is random, and we will get answer $x$ with probability $|(U\phi)_x|^2$.
Thus, a quantum computer is a kind of universal quantum mechanics simulator, where we \emph{input} the laws of physics $U$.

\subsection{Quantum circuits}

In physics, the state set $S$ is often infinite, and sometimes even uncountably infinite (e.g. the position of a particle),
but in quantum programming the set $S$ is taken to be strings of $k$ bits, so that $|S| = 2^k$.
The matrix $U$ is a $2^k$-by-$2^k$ matrix. One might wonder how we even input the $U$ to the quantum computer, if it contains an exponential amount of data.

The answer is that we can't quite input \emph{any} matrix $U$; it must be encoded as a \emph{quantum circuit}.
A quantum circuit is a list of operations we do on the state $x$ of $n$ bits, where each operation operates on some small subset of the bits and leaves the rest of the bits alone.

Often, a small set of operations is used, such as the \emph{Hadamard gate} and the \emph{CNOT gate}.
The Hadamard gate operates one bit, and the CNOT gate operates on two bits.

In order to describe what they do, we have to introduce a bit of notation.
We use the notation $\phi = \ket{01001}$ for the state $\phi$ where $\phi_{01001} = 1$ and $\phi_x = 0$ otherwise, \ie the state that puts all probability amplitude on $01001$.

\newcommand{\Ha}{\mathsf{H}}
\newcommand{\CNOT}{\mathsf{CNOT}}
\newcommand{\CCNOT}{\mathsf{CCNOT}}

The Hadamard gate $\Ha$ works on one bit, and is defined as:
\begin{align*}
  \Ha\ket{0} = \frac{1}{\sqrt{2}}(\ket{0} + \ket{1}) \\
  \Ha\ket{1} = \frac{1}{\sqrt{2}}(\ket{0} - \ket{1})
\end{align*}
Equivalently, we can define it using matrix notation, as
\begin{align*}
  \Ha = \frac{1}{\sqrt{2}}\begin{pmatrix}
    1 & 1 \\
    1 & -1
  \end{pmatrix}
\end{align*}

If we have $n$ bits in the state, then we have Hadamard gates $\Ha_1, \Ha_2, \cdots, \Ha_n$, each operating on a different bit.
This is what $\Ha_1$ does:
\begin{align*}
  \Ha_1 \ket{0 b_1 b_2 \cdots b_n} = \frac{1}{\sqrt{2}}(\ket{0 b_1 b_2 \cdots b_n} + \ket{1 b_1 b_2 \cdots b_n}) \\
  \Ha_1 \ket{1 b_1 b_2 \cdots b_n} = \frac{1}{\sqrt{2}}(\ket{0 b_1 b_2 \cdots b_n} - \ket{1 b_1 b_2 \cdots b_n})
\end{align*}
Try writing down $H_1$ has a $2^n$-by-$2^n$ matrix, and you'll see why this notation is useful.

The CNOT gate is defined as:
\begin{align*}
  \CNOT \ket{00} = \ket{00} \\
  \CNOT \ket{01} = \ket{01} \\
  \CNOT \ket{10} = \ket{11} \\
  \CNOT \ket{11} = \ket{10}
\end{align*}

The CNOT gate is a classical gate, in the sense that it only changes some definite states into other definite states.
In order for the operation to be unitary, all possible states have to appear on the right hand sides, \ie it wouldn't be valid to have an operation with
$M \ket{00} = \ket{00}$ and $M \ket{01} = \ket{00}$, as this wouldn't be unitary.

The $\CNOT$ gate flips the second bit if the first bit is $1$.
Similarly, there is the $\CCNOT$ gate, which operates on $3$ bits, and flips the third bit if both the first and second bits are $1$.
Like with to the Hadamard gate, if we have $n$ bits we have $\CNOT_{ij}$ and $\CCNOT_{ijk}$ gates, operating on those bits.
The Hadamard and CCNOT gates are a universal set of gates, which means that any unitary $2^n$-by-$2^n$ matrix can be arbitrarily closely approximated as a product of the $\Ha_i$ and the $\CCNOT_{ijk}$ gates.

Thus, a we input into the quantum computer a list of operations, e.g.
\begin{align*}
  U = H_1 \cdot \CNOT_{12} \cdot H_2 \cdots H_4
\end{align*}
and an initial state $x$, and the quantum computer will sample for us a random final state $y$ with probability $p_y = |(U\ket{x})_y|^2$.

\subsection{The Deutsch-Jozsa algorithm}

TODO

\bibliographystyle{alphaurl}
\bibliography{references}


\end{document}
